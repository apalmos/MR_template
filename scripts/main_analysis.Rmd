---
title: "ALS_MR"
author: "Alish Palmos"
date: "09/02/2021"
output: html_document
editor_options:
  chunk_output_type: console
---

<style type="text/css">
  body{
  font-size: 12pt;
}
</style>

#Set-up
```{r echo=FALSE}
rm(list=ls())
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

setwd("/scratch/groups/ukbiobank/usr/alish/AD_MR/")
```

```{r include=FALSE}
library(data.table)
library(jtools)
library(knitr)
library(broom)
library(sandwich)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(sgof)
library(TwoSampleMR)
library(qvalue)
library(kableExtra)
library(vroom)

```


```{r}
#get MR function
get_mr <- function(study, dir, extra = NULL){

  if(is.null(extra)){

  current_dir <- dir
  setwd(paste0(current_dir,"/",study,"_mr/output/"))

  list <- list.files(pattern = "*.gsmr")

  mr <- lapply(list, read.delim)

  bind <- do.call(rbind.data.frame, mr)

  title <- str_to_title(study)

  bind$study <- paste0(title)

  bind$file_name <- rep(list, each=2)

  bind <- bind %>%
    filter(nsnp >= 1)

  bind_n <- count(bind)

  assign(paste0(study,"_mr"),value = bind)

  }

  else

    current_dir <- dir

  setwd(paste0(current_dir,"/",study,"_mr/",extra,"output/"))

  list <- list.files(pattern = "*.gsmr")

  mr <- lapply(list, read.delim)

  bind <- do.call(rbind.data.frame, mr)

  title <- str_to_title(study)

  bind$study <- paste0(title)

  bind$file_name <- rep(list, each=2)

  bind <- bind %>%
    filter(nsnp >= 1)

  bind_n <- count(bind)

  assign(paste0(study,"_mr"),value = bind)

}

```


This RMarkdown shows the results from a MRWAS (Mendelian Randomization Wide Association Study).

All currently available GWAS summary statistics of inflammatory markers were amassed over the course a few months.  


Covid GWAS used in this study:

Very severe respiratory confirmed covid vs. not hospitalized covid - October data release (https://www.covid19hg.org/results/)



Sun et al: https://pubmed.ncbi.nlm.nih.gov/29875488

Suhre et al: https://pubmed.ncbi.nlm.nih.gov/28240269

Wood et al: https://pubmed.ncbi.nlm.nih.gov/23696881

Sliz et al: https://www.ncbi.nlm.nih.gov/pubmed/?term=31217265

Folkerson et al: http://dx.plos.org/10.1371/journal.pgen.1006706

Ahola et al: https://pubmed.ncbi.nlm.nih.gov/27989323

Scallop et al: https://www.nature.com/articles/s42255-020-00287-2#Abs1

Bretherik et al: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7337286


Note that more studies are available for analyses. They're currently being cleaned and added as the data generation protocol progresses.


GSMR was used as the base MR method: https://www.nature.com/articles/s41467-017-02317-2


P-value threshold was set to 5E-6, due to lack of power in some GWAS. Thus, this study is exploratory.


Only comparisons where 10+ SNPs were in common between the exposure and the outcome were included. This is routine MR practice.


Bonferroni p-value threshold is stated below.

#PROTEIN -> AD
#Get all GSMR data

```{r echo=FALSE}

sun_mr <- get_mr(study = "sun", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
suhre_mr <- get_mr(study = "suhre", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
folk_mr <- get_mr(study = "folk", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
sliz_mr <- get_mr(study = "sliz", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
wood_mr <- get_mr(study = "wood", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
ahol_mr <- get_mr(study = "ahol", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
scal_mr <- get_mr(study = "scal", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
hill_mr <- get_mr(study = "hill", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
hogl_mr <- get_mr(study = "hogl", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
enroth_mr <- get_mr(study = "enroth", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")
deco_mr <- get_mr(study = "deco", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/")

```

# Combine all to count how many exposures we had as proteins
```{r echo=FALSE}
# combine all to count how many exposures and outcomes we had
mr_df_all <- rbind(folk_mr, sliz_mr, suhre_mr, sun_mr, wood_mr, ahol_mr, scal_mr, hill_mr, hogl_mr, enroth_mr, deco_mr)
als <- str_count(mr_df_all$Exposure, "AD_Schwartzentruber")
als[is.na(als)] <- 0
sum(als)
```

# Combine all to count how many exposures we had as AD
```{r}

markers <- mr_df_all[mr_df_all$Outcome %like% "AD_Schwartzentruber", ]
nrow(markers)

```

# Combine full data, work out odds ratios and 95% CI
```{r}

mr_df_all$Beta_exponent <- exp(mr_df_all$bxy)
mr_df_all$LCI <- mr_df_all$Beta_exponent - (mr_df_all$se * 1.96)
mr_df_all$UCI <- mr_df_all$Beta_exponent + (mr_df_all$se * 1.96)

mr_df_all$Exposure <- gsub(".txt", "",mr_df_all$Exposure)
mr_df_all$Outcome <- gsub(".txt", "",mr_df_all$Outcome)
```

# Compute q-values and add them to the large combined data frame
```{r}
pvalues <- mr_df_all$p
qobj <- qvalue(p = pvalues)
lfdr <- qobj$lfdr
summary(qobj)
hist(qobj)
plot(qobj)

qvalues <- as.matrix(qobj$qvalues)
mr_df_all$qvalue <- cbind(qvalues)
```

# Adjusted p-values using SGoF method
```{r}
p <- SGoF(mr_df_all$p)
summary(p)

plot(p)

p_list <- p$Adjusted.pvalues

mr_df_all <- mr_df_all[order(mr_df_all$p),]
mr_df_all$sgof <- p_list
```

# All effects AD outcome

```{r}

AD_outcome <- mr_df_all[mr_df_all$Outcome %like% "AD_Schwartzentruber", ]

  AD_outcome %>%
  kbl() %>%
  kable_classic_2(full_width = F)

```

# Sort by significant p-values and filter
```{r}
mr_df_filtered <- AD_outcome %>%
  filter(qvalue < 0.05)

mr_df_filtered <- mr_df_filtered %>%
  rename(Beta = bxy, StandardError = se, Pvalue = p, SNPs = nsnp, LowerCI = LCI, UpperCI =  UCI)

mr_df_filtered <- mr_df_filtered %>% arrange(desc(Beta_exponent))

mr_df_filtered$Log_Beta <- log(mr_df_filtered$Beta_exponent)
mr_df_filtered$Log_LowerCI <- log(mr_df_filtered$LowerCI)
mr_df_filtered$Log_UpperCI <- log(mr_df_filtered$UpperCI)

  mr_df_filtered %>%
  kbl() %>%
  kable_classic_2(full_width = F)
```

# Create a figure with AD as the outcome
```{r fig.width=20, fig.height=40, echo=FALSE}

mr_df_chart <- mr_df_filtered %>%
  filter(qvalue < 0.0001)

AD_outcome_stringent <- mr_df_chart
vroom_write(x = AD_outcome_stringent, file = "/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_outcome_stringent")

mr_df_chart <- mr_df_chart[complete.cases(mr_df_chart), ]

#Tidy up the names of some proteins
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)

mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)
mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)
mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)
mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)

mr_df_chart <- mr_df_chart[!duplicated(mr_df_chart$Exposure), ]

library(scales)

ggplot(mr_df_chart, aes(x=reorder(as.factor(Exposure), Beta_exponent) , y=Beta_exponent)) +
    geom_boxplot(fill="slateblue") + coord_flip() + geom_errorbar(aes(ymax = UpperCI, ymin = LowerCI))+ ggtitle("Outcome - Alzheimer's") +
  xlab("Exposure Variable") + ylab("Odds Ratio (95% Confidence Interval)")+ geom_hline(yintercept=1, linetype="dashed", color = "red") +
  theme_bw() + theme(text=element_text(size=25, family="Arial")) +
  geom_hline(linetype = "dashed", yintercept = 1) +
    theme(panel.grid.major.x = element_line(size = 0.5,
                                        linetype = 'dashed',
                                        colour = "gray41"),
        panel.grid.major.y = element_line(size = 0.1,
                                        linetype = 'solid',
                                        colour = "gray62")) +
  scale_y_log10(breaks = c(-1, 0.5, 1, 1.5, 2, 2.5)) +
  guides(color = guide_legend(reverse = TRUE)) +
  coord_flip(clip = "off", ylim = c(-1,3))

```

# AD -> PROTEIN
#Get all GSMR data

```{r echo=FALSE}

sun_mr <- get_mr(study = "sun", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
suhre_mr <- get_mr(study = "suhre", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
folk_mr <- get_mr(study = "folk", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
sliz_mr <- get_mr(study = "sliz", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
wood_mr <- get_mr(study = "wood", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
ahol_mr <- get_mr(study = "ahol", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
scal_mr <- get_mr(study = "scal", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
hill_mr <- get_mr(study = "hill", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
hogl_mr <- get_mr(study = "hogl", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
enroth_mr <- get_mr(study = "enroth", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")
deco_mr <- get_mr(study = "deco", dir = "/scratch/groups/ukbiobank/usr/alish/AD_MR/", extra = "ADexp/")

```

# Combine all to count how many exposures we had as proteins
```{r echo=FALSE}
# combine all to count how many exposures and outcomes we had
mr_df_all <- rbind(folk_mr, suhre_mr, sun_mr, wood_mr, ahol_mr, scal_mr, hill_mr, hogl_mr, enroth_mr, deco_mr)
als <- str_count(mr_df_all$Exposure, "AD")
als[is.na(als)] <- 0
sum(als)
```

# Combine all to count how many exposures we had as ALS
```{r}
markers <- mr_df_all[mr_df_all$Exposure %like% "AD_Schwartzentruber", ]

nrow(markers)
```

# Combine full data, work out odds ratios and 95% CI
```{r}

mr_df_all$Beta_exponent <- exp(mr_df_all$bxy)
mr_df_all$LCI <- mr_df_all$Beta_exponent - (mr_df_all$se * 1.96)
mr_df_all$UCI <- mr_df_all$Beta_exponent + (mr_df_all$se * 1.96)

mr_df_all$Exposure <- gsub(".txt", "",mr_df_all$Exposure)
mr_df_all$Outcome <- gsub(".txt", "",mr_df_all$Outcome)
```

# Compute q-values and add them to the large combined data frame
```{r}
pvalues <- mr_df_all$p
qobj <- qvalue(p = pvalues)
lfdr <- qobj$lfdr
summary(qobj)
hist(qobj)
plot(qobj)

qvalues <- as.matrix(qobj$qvalues)
mr_df_all$qvalue <- cbind(qvalues)
```


# Adjusted p-values using SGoF method
```{r}
p <- SGoF(mr_df_all$p)
summary(p)

plot(p)

p_list <- p$Adjusted.pvalues

mr_df_all <- mr_df_all[order(mr_df_all$p),]
mr_df_all$sgof <- p_list
```

# All effects AD exposure
```{r}

mr_df_all$p.adjust <- p.adjust(p = mr_df_all$p, method = "fdr")

AD_exposure <- mr_df_all[mr_df_all$Exposure %like% "AD_Schwartzentruber", ]

  AD_exposure %>%
  kbl() %>%
  kable_classic_2(full_width = F)

```

# Sort by significant p-values
```{r}
mr_df_filtered <- AD_exposure %>%
  filter(qvalue < 0.05)

mr_df_filtered <- mr_df_filtered %>%
  rename(Beta = bxy, StandardError = se, Pvalue = p, SNPs = nsnp, LowerCI = LCI, UpperCI =  UCI, AdjustedPvalue = p.adjust)

mr_df_filtered <- mr_df_filtered %>% arrange(desc(Beta_exponent))

mr_df_filtered$Log_Beta <- log(mr_df_filtered$Beta_exponent)
mr_df_filtered$Log_LowerCI <- log(mr_df_filtered$LowerCI)
mr_df_filtered$Log_UpperCI <- log(mr_df_filtered$UpperCI)

  mr_df_filtered %>%
  kbl() %>%
  kable_classic_2(full_width = F)                              

```

# Create a figure with AD as the exposure

```{r echo=FALSE}

mr_df_chart <- mr_df_filtered %>%
  filter(qvalue < 0.0001)

AD_exposure_stringent <- mr_df_chart
vroom_write(x = AD_exposure_stringent, file = "/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_exposure_stringent")

mr_df_chart <- mr_df_chart[complete.cases(mr_df_chart), ]

#Tidy up the names of some proteins
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)
mr_df_chart$Exposure <- sub("^(.*)[.].*", "\\1",mr_df_chart$Exposure)

mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)
mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)
mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)
mr_df_chart$Outcome <- sub("^(.*)[.].*", "\\1",mr_df_chart$Outcome)

mr_df_chart <- mr_df_chart[!duplicated(mr_df_chart$Outcome), ]

library(scales)

ggplot(mr_df_chart, aes(x=reorder(as.factor(Outcome), Beta_exponent) , y=Beta_exponent)) +
    geom_boxplot(fill="slateblue") + coord_flip() + geom_errorbar(aes(ymax = UpperCI, ymin = LowerCI))+ ggtitle("Exposure - Alzheimer's") +
  xlab("Outcome Variable") + ylab("Odds Ratio (95% Confidence Interval)")+ geom_hline(yintercept=1, linetype="dashed", color = "red") + ylim(-0.5, 2.5) +
  theme_bw() + theme(text=element_text(size=10, family="Arial")) +
    theme(panel.grid.major.x = element_line(size = 0.5,
                                        linetype = 'dashed',
                                        colour = "gray41"),
        panel.grid.major.y = element_line(size = 0.1,
                                        linetype = 'solid',
                                        colour = "gray62")) +
  scale_y_log10(breaks = c(-1, 0.5, 1, 1.5, 2, 2.5)) +
  guides(color = guide_legend(reverse = TRUE)) +
  coord_flip(clip = "off", ylim = c(-1,3))

```


#SENSITIVITY ANALYSES

# Functions to get SNP infro from GSMR
```{r GSMR fucntions for creating figures, no need to take note of this}

# ************************************************** #
#              Read exposure and outcome             #
# ************************************************** #
read_gsmr_trait = function(file_con) {
    expo_str = scan(file_con, nlines=1, quiet=TRUE, what="");
    outcome_str = scan(file_con, nlines=1, quiet=TRUE, what="");
    strbuf = scan(file_con, nlines=1, quiet=TRUE, what="");
    return(list(expo_str=expo_str, outcome_str=outcome_str))
}

# ************************************************** #
#                  Read GSMR result                  #
# ************************************************** #
read_gsmr_result = function(file_con) {
    expo_str = outcome_str = bxy = bxy_se = bxy_pval = bxy_m = c()
    while(1) {
        strbuf = scan(file_con, nlines=1, quiet=TRUE, what="");
        if(strbuf[1] == "#gsmr_end") break;
        if(strbuf[1] == "Exposure") next;
        expo_str = c(expo_str, strbuf[1]);
        outcome_str = c(outcome_str, strbuf[2]);
        bxy = c(bxy, as.numeric(strbuf[3]));
        bxy_se = c(bxy_se, as.numeric(strbuf[4]));
        bxy_pval = c(bxy_pval, as.numeric(strbuf[5]));
        bxy_m = c(bxy_m, as.numeric(strbuf[6]));
    }
    return(cbind(expo_str, outcome_str, bxy, bxy_se, bxy_pval, bxy_m))
}

# ************************************************** #
#                  Read SNP effects                  #
# ************************************************** #
read_snp_effect = function(file_con) {
    snp_effect = c()
    while(1) {
        strbuf = scan(file_con, nlines=1, quiet=TRUE, what="");
        if(strbuf[1] == "#effect_end") break;
        snp_effect = rbind(snp_effect, strbuf);
        print(length(strbuf))
        if(length(strbuf)<14) print(strbuf)
    }
    return(snp_effect)
}

# ************************************************** #
#                  Read SNP instruments              #
# ************************************************** #
read_snp_instru = function(file_con, snplist, nexpo, noutcome) {
    nrow = length(snplist); ncol = nexpo+noutcome
    snp_instru = matrix(NA, nrow, ncol)
    while(1) {
        strbuf = scan(file_con, nlines=1, quiet=TRUE, what="");
        if(strbuf[1] == "#marker_end") break;
        expo_indx = as.numeric(strbuf[1]); outcome_indx = as.numeric(strbuf[2]);
        forward_flag = TRUE;
        if(expo_indx < outcome_indx) {
            outcome_indx = outcome_indx - nexpo
        } else {
            expo_indx = expo_indx - nexpo
            forward_flag = FALSE;
        }
        snpbuf = scan(file_con, nlines=1, quiet=TRUE, what="");
        snp_indx = match(snpbuf, snplist)
        posbuf = rep(0, nrow); posbuf[snp_indx] = 1;
        indxbuf = expo_indx
        if(!forward_flag) indxbuf = indxbuf + nexpo
        if(length(which(!is.na(snp_instru[,indxbuf])))==0) {
            snp_instru[,indxbuf] = posbuf;
        } else {
            snp_instru[,indxbuf] = paste(snp_instru[,indxbuf], posbuf, sep="")
        }
    }
    return(snp_instru)
}

# ************************************************** #
#          Read output by GCTA-GSMR for plot         #
# ************************************************** #
read_gsmr_data = function(gsmr_effect_file) {
    trait_flag = gsmr_flag = marker_flag = effect_flag = FALSE;
    file_con = file(gsmr_effect_file, "r")
    while(1) {
        strbuf = scan(file_con, nlines=1, quiet=TRUE, what="");
        if(strbuf == "#trait_begin") {
            # Read the exposures and outcomes
            resbuf = read_gsmr_trait(file_con);
            expo_str = resbuf$expo_str;
            outcome_str = resbuf$outcome_str;
            pheno_str = c(expo_str, outcome_str);
            nexpo = length(expo_str); noutcome = length(outcome_str)
            trait_flag = TRUE;
        } else if(strbuf == "#gsmr_begin") {
            # Read the GSMR result
            bxy_result = read_gsmr_result(file_con);
            colnames(bxy_result) = c("Exposure", "Outcome", "bxy", "se", "p", "n_snps")
            gsmr_flag = TRUE;
        } else if(strbuf == "#effect_begin") {
            # Read the summary statistics
            snp_effect = read_snp_effect(file_con);
            snplist = as.character(snp_effect[,1])
            effect_flag = TRUE;
        } else if(strbuf == "#marker_begin") {
            # Read the SNPs
            snp_instru = read_snp_instru(file_con, snplist, nexpo, noutcome);
            snp_effect = cbind(snp_effect[,1], snp_instru, snp_effect[,-1])
            marker_flag = TRUE;
        }
        if(trait_flag==T & gsmr_flag==T & marker_flag==T & effect_flag==T) break;
    }
    return(list(pheno=c(nexpo, noutcome, pheno_str), bxy_result=bxy_result, snp_effect = snp_effect))
}

# ************************************************** #
#         Display summary of the gsmr data           #
# ************************************************** #
gsmr_summary = function(gsmr_data) {
    message("\n## Exposure and outcome")
    pheno_str = gsmr_data$pheno[c(-1,-2)]
    # exposure
    nexpo = as.numeric(gsmr_data$pheno[1]);
    noutcome = as.numeric(gsmr_data$pheno[2]);
    logger_m = paste(nexpo, "exposure(s):");
    logger_m = paste(logger_m, gsmr_data$pheno[3])
    if(nexpo > 1) {
        for(i in 2 : nexpo)
            logger_m = paste(logger_m, gsmr_data$pheno[i+2], sep=", ")
    }
    message(logger_m)
    # outcome
    logger_m = paste(noutcome, "outcome(s):");
    logger_m = paste(logger_m, gsmr_data$pheno[3+nexpo])
    if(noutcome > 1) {
        for(i in 2 : noutcome)
            logger_m = paste(logger_m, gsmr_data$pheno[i+2+nexpo], sep=", ")
    }
    message(logger_m)

    message("\n## GSMR result")
    m_bxy_rst = data.frame(gsmr_data$bxy_result)
    print(m_bxy_rst)
}


# ************************************************** #
#               Retrieve SNP effects                 #
# ************************************************** #
gsmr_snp_effect = function(gsmr_data, expo_str, outcome_str) {
   # index of SNP instruments
    pheno_str = as.character(gsmr_data$pheno[c(-1,-2)])
    nexpo = as.numeric(gsmr_data$pheno[1])
    noutcome = as.numeric(gsmr_data$pheno[2])
    expo_indx = match(expo_str, pheno_str)
    if(is.na(expo_indx)) stop("\"", expo_str, "\" is not found.")
    outcome_indx = match(outcome_str, pheno_str)
    if(is.na(outcome_indx)) stop("\"", outcome_str, "\" is not found.")
    forward_flag = TRUE;
    if(expo_indx > outcome_indx) forward_flag = FALSE;
    if(forward_flag) {
        outcome_indx = outcome_indx - nexpo;
    } else {
        expo_indx = expo_indx - nexpo;
    }
    indxbuf = expo_indx + 1
    if(!forward_flag) indxbuf = indxbuf + nexpo
    strbuf = as.character(substr(gsmr_data$snp_effect[,indxbuf], outcome_indx, outcome_indx))
    snpindx = which(strbuf=="1")
    if(length(snpindx) < 1) stop("Not enough SNPs retained.")
    # bxy
    indxbuf = which(gsmr_data$bxy_result[,1]==expo_str & gsmr_data$bxy_result[,2]==outcome_str)
    bxy = as.numeric(gsmr_data$bxy_result[indxbuf, 3])
    # SNP effects
    if(forward_flag) {
        indxbuf1 = 1 + nexpo + noutcome + 3 + (expo_indx-1)*2 + 1
        indxbuf2 = 1 + nexpo + noutcome + 3 + nexpo*2 + (outcome_indx-1)*2 + 1
    } else {
        indxbuf1 = 1 + nexpo + noutcome + 3 + nexpo*2 + (expo_indx-1)*2 + 1
        indxbuf2 = 1 + nexpo + noutcome + 3 + (outcome_indx-1)*2 + 1
    }
    snpid = as.character(gsmr_data$snp_effect[snpindx,1])
    bzx = as.numeric(gsmr_data$snp_effect[snpindx,indxbuf1]); indxbuf1 = indxbuf1 + 1;
    bzx_se = as.numeric(gsmr_data$snp_effect[snpindx,indxbuf1]);
    bzx_pval = pchisq((bzx/bzx_se)^2, 1, lower.tail=F);
    bzy = as.numeric(gsmr_data$snp_effect[snpindx,indxbuf2]); indxbuf2 = indxbuf2 + 1;
    bzy_se = as.numeric(gsmr_data$snp_effect[snpindx,indxbuf2]);
    bzy_pval = pchisq((bzy/bzy_se)^2, 1, lower.tail=F);
    return(list(snp=snpid, bxy=bxy, bzx=bzx, bzx_se=bzx_se, bzx_pval=bzx_pval, bzy=bzy, bzy_se=bzy_se, bzy_pval=bzy_pval))
}

# ************************************************** #
#                  Plot bzy vs bzx                   #
# ************************************************** #
plot_snp_effect = function(expo_str, outcome_str, bxy, bzx, bzx_se, bzy, bzy_se, effect_col=colors()[75]) {
    vals = c(bzx-bzx_se, bzx+bzx_se)
    xmin = min(vals); xmax = max(vals)
    vals = c(bzy-bzy_se, bzy+bzy_se)
    ymin = min(vals); ymax = max(vals)
    plot(bzx, bzy, pch=20, cex=0.8, bty="n", cex.axis=1.1, cex.lab=1.2,
         col=effect_col, xlim=c(xmin, xmax), ylim=c(ymin, ymax),
         xlab=substitute(paste(trait, " (", italic(b[zx]), ")", sep=""), list(trait=expo_str)),
         ylab=substitute(paste(trait, " (", italic(b[zy]), ")", sep=""), list(trait=outcome_str))
    )
    if(!is.na(bxy)) abline(0, bxy, lwd=1.5, lty=2, col="dim grey")
    ## Standard errors
    nsnps = length(bzx)
    for( i in 1:nsnps ) {
        # x axis
        xstart = bzx[i] - bzx_se[i]; xend = bzx[i] + bzx_se[i]
        ystart = bzy[i]; yend = bzy[i]
        segments(xstart, ystart, xend, yend, lwd=1.5, col=effect_col)
        # y axis
        xstart = bzx[i]; xend = bzx[i]
        ystart = bzy[i] - bzy_se[i]; yend = bzy[i] + bzy_se[i]
        segments(xstart, ystart, xend, yend, lwd=1.5, col=effect_col)


    }

    p1_recorded <- recordPlot()
ggdraw(p1_recorded)

}

# ************************************************** #
#             Plot bzy_pval vs bzx_pval              #
# ************************************************** #
plot_snp_pval = function(expo_str, outcome_str, bzx_pval, bzy_pval, gwas_thresh, truncation, effect_col) {
    eps = 1e-300; truncation = -log10(truncation);
    if(truncation > 300) {
        warning("The minimal truncated p-value would be 1e-300.")
        truncation = 300
    }
    bzx_pval = -log10(bzx_pval + eps);
    bzy_pval = -log10(bzy_pval + eps);
    pval = c(bzx_pval, bzy_pval)
    min_val = 0; max_val = max(pval);
    max_val = ifelse(max_val > truncation, truncation, max_val)
    gwas_thresh = -log10(gwas_thresh);
    plot(bzx_pval, bzy_pval, pch=20, cex=0.8, bty="n", cex.axis=1.1, cex.lab=1.2,
         col=effect_col, xlim=c(min_val, max_val), ylim=c(min_val, max_val),
         xlab=substitute(paste(trait, " (", -log[10], italic(P)[zx], ")", sep=""), list(trait=expo_str)),
         ylab=substitute(paste(trait, " (", -log[10], italic(P[zy]), ")", sep=""), list(trait=outcome_str)))
    abline(h=gwas_thresh, lty=2, lwd=1.5, col="maroon")
}

# ************************************************** #
#                Plot bxy vs bzx_pval                #
# ************************************************** #
plot_snp_bxy = function(expo_str, outcome_str, bxy, bzx_pval, effect_col) {
    eps = 1e-300;
    bzx_pval = -log10(bzx_pval + eps);
    xmin = min(bxy, na.rm=T); xmax = max(bxy, na.rm=T)
    ymin = min(bzx_pval); ymax = max(bzx_pval);
    plot(bxy, bzx_pval, pch=20, cex=0.8, bty="n", cex.axis=1.1, cex.lab=1.2,
         col=effect_col, xlim=c(xmin, xmax), ylim=c(ymin, ymax),
         xlab=substitute(paste(italic(hat(b)[xy]), " (", trait1, " -> ", trait2, ")", sep=""), list(trait1=expo_str, trait2=outcome_str)),
         ylab=substitute(paste(trait, " (", -log[10], italic(P[zx]), ")", sep=""), list(trait=expo_str)))
}

# ************************************************** #
#                  Effect size plot                  #
# ************************************************** #
# expo_str, exposure
# outcome_str, outcome
# effect_col, plotting colour
plot_gsmr_effect = function(gsmr_data, expo_str, outcome_str, effect_col=colors()[75]) {
    resbuf = gsmr_snp_effect(gsmr_data, expo_str, outcome_str);
    bxy = resbuf$bxy
    bzx = resbuf$bzx; bzx_se = resbuf$bzx_se;
    bzy = resbuf$bzy; bzy_se = resbuf$bzy_se;
    # plot
    plot_snp_effect(expo_str, outcome_str, bxy, bzx, bzx_se, bzy, bzy_se, effect_col)
}

# ************************************************** #
#                    P-value plot                    #
# ************************************************** #
# expo_str, exposure
# outcome_str, outcome
# effect_col, plotting colour
plot_gsmr_pvalue = function(gsmr_data, expo_str, outcome_str, gwas_thresh=5e-8, truncation=1e-50, effect_col=colors()[75]) {
    resbuf = gsmr_snp_effect(gsmr_data, expo_str, outcome_str);
    bzx_pval = resbuf$bzx_pval; bzy_pval = resbuf$bzy_pval;
    # plot
    plot_snp_pval(expo_str, outcome_str, bzx_pval, bzy_pval, gwas_thresh, truncation, effect_col)
}

# ************************************************** #
#                     bxy distribution plot                         #
# ************************************************** #

# expo_str, exposure
# outcome_str, outcome
# effect_col, plotting colour
plot_bxy_distribution = function(gsmr_data, expo_str, outcome_str, effect_col=colors()[75]) {
    resbuf = gsmr_snp_effect(gsmr_data, expo_str, outcome_str);
    bzx = resbuf$bzx; bzx_pval = resbuf$bzx_pval;
    bzy = resbuf$bzy;
    bxy = bzy/bzx
    # plot
    plot_snp_bxy(expo_str, outcome_str, bxy, bzx_pval, effect_col)
}

```


# PROTEIN -> AD
# Create a loop for getting all the GSMR data into a Google Sheet
```{r}

# mr_df_original_AD <- AD_outcome_stringent
  # arrange(aesc(qvalue))

mr_df_original_AD <- vroom(file = "/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_outcome_stringent")

# library(vroom)
# library(openxlsx)
# library(cowplot)

mr_df_original_AD$study <- tolower(mr_df_original_AD$study)
mr_df_original_AD$clean_names <-  gsub('\\..*', '', mr_df_original_AD$Exposure)
mr_df_original_AD$file_name <- gsub(".gsmr", "", mr_df_original_AD$file_name)

filename <- mr_df_original_AD$file_name
study <- mr_df_original_AD$study
mr_df_original_AD$names <- make.names(mr_df_original_AD$Exposure,unique=T)
names <- mr_df_original_AD$names
marker <- mr_df_original_AD$Exposure
brain <- mr_df_original_AD$Outcome
path <- "/scratch/groups/ukbiobank/usr/alish/AD_MR/"
label <- paste(mr_df_original_AD$clean_names, mr_df_original_AD$study, sep = "_")
no_dups <- make.unique(label, sep = ".")


number <- 1

rm(wb)

wb <- createWorkbook()

for(number in 1:length(filename)){

  current_marker <- filename[number]

  file_path_gsmr <- paste0(path,study[number],"_mr/","output/",current_marker,".eff_plot.gz")

  gsmr_data <- read_gsmr_data(file_path_gsmr)

  gsmr_data$pheno[3] <- label[number]
  gsmr_data$bxy_result[1] <- label[number]
  gsmr_data$bxy_result[4] <- label[number]

  graph <- plot_gsmr_effect(gsmr_data,label[number],"AD_Schwartzentruber", colors()[75])

  ggsave(filename = paste0(label[number]), plot = graph, path = paste0(path,"/sensitivity/AD_outcome/"), width = 6, height = 4, device='tiff', dpi=700)

  snp_data <- gsmr_snp_effect(gsmr_data,label[number],"AD_Schwartzentruber")

  snp_data <- as.data.frame(snp_data)

  # current_name <- substring(paste0(names[number]), 1, 30)

  addWorksheet(wb, sheetName = paste0(no_dups[number]))

  writeData(wb, sheet = paste0(no_dups[number]), snp_data, rowNames = TRUE)

}

saveWorkbook(wb, file = paste0(path,"sensitivity/protein_AD_gsmr_results.xlsx"), overwrite = TRUE)

```

#TwoSampleMR Sensitivity Analyses

```{r}

# library(vroom)
# library(openxlsx)
# library(cowplot)

mr_df_original_AD <- AD_outcome_stringent
  # arrange(aesc(qvalue))

mr_df_original_AD$file_name <- gsub(".gsmr", "", mr_df_original_AD$file_name)
mr_df_original_AD$clean_names <-  gsub('\\..*', '', mr_df_original_AD$Exposure)
mr_df_original_AD$file_name <- gsub(".txt", "", mr_df_original_AD$file_name)
mr_df_original_AD$study <- tolower(mr_df_original_AD$study)

#Read in the SNPs from the excel file
filename <- mr_df_original_AD$file_name
study <- mr_df_original_AD$study
mr_df_original_AD$names <- make.names(mr_df_original_AD$Exposure,unique=T)
names <- mr_df_original_AD$names
marker <- mr_df_original_AD$Exposure
brain <- mr_df_original_AD$Outcome
path <- "/scratch/groups/ukbiobank/usr/alish/AD_MR/"
all_protein <- list.files("/scratch/groups/ukbiobank/usr/alish/AD_MR/sensitivity/AD_outcome/", include.dirs = F)
all_protein <- all_protein[-1]
label <- paste(mr_df_original_AD$clean_names, mr_df_original_AD$study, sep = "_")
filename <- toupper(filename)
no_dups <- make.unique(label, sep = ".")


# Make the columns as follows:
# SNP                 
# beta                
# SE                 
# effect_allele      
# non-effective allele
# p-value            
# effect_allele freq

number <- 1

# library(TwoSampleMR)

rm(wb)

wb <- createWorkbook()

  #using TwoSampleMR, read in the outcome of interest
  outcome_dat <- read_outcome_data(
  filename = paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_Schwartzentruber.txt"),
  sep = " ",                
  snp_col = "variant_id",          
  beta_col = "beta",         
  se_col = "standard_error",        
  effect_allele_col = "effect_allele",  
  other_allele_col = "other_allele",
  eaf = "effect_allele_frequency",
  samplesize_col = "472868",
  pval_col = "p_value")

  outcome_dat$outcome=paste0("AD")

for(number in 86:length(filename)){

  loadWorkbook(file = paste0(path,"sensitivity/protein_AD_sensitivity.xlsx"), xlsxFile = NULL, isUnzipped = FALSE)


  #read in the workbook with all our significant proteins
  current_protein <- readWorkbook(xlsxFile = paste0(path,"sensitivity/protein_AD_gsmr_results.xlsx"), sheet = paste0(label[number]), rowNames = TRUE)

  #get the SNPs of interest
  df <- current_protein %>%
    select(SNP = snp)

  #get the whole GWAS from the same protein
  original_protein <- vroom(paste0("/scratch/groups/gwas_sumstats/cleaned/blood_biomarkers/",filename[number],".gz"))

  #join the shorter and the longer protein data together
  full_df <-  inner_join(df, original_protein)

  #get all the columns that we need
  try(
    full_df <- full_df %>%
  select(SNP, BETA, SE, A1, A2, P, MAF)
  )
  try(
    full_df <- full_df %>%
  select(SNP, BETA, SE = STDERR, A1, A2, P, MAF)
  )

  #get all the columns that we need
  full_df <- full_df %>%
  select(SNP,
         beta = BETA,
         se = SE,
         effect_allele = A1,
         other_allele = A2,
         eaf = MAF
         )

  #format
  exposure_dat <- format_data(full_df, type = "exposure")

  exposure_dat$exposure=paste0(label[number])

  #Harmonisation of SNP instruments between exposures and outcomes
  harmonized <- harmonise_data(exposure_dat = exposure_dat, outcome_dat = outcome_dat, action=2)

  # get the data ready
  # all exposures -> Covid
  dataMR_keep=subset(harmonized, mr_keep==TRUE)

  # perform TwoSampleMR for all pairs
  MR_toCovid_keep<- mr(dataMR_keep, method_list = c("mr_two_sample_ml", "mr_egger_regression","mr_weighted_median", "mr_ivw", "mr_ivw_radial", "mr_ivw_mre", "mr_ivw_fe", "mr_weighted_mode"))

  #get the name of the current marker and brain volume
  current_name <- substring(paste0(no_dups[number],"_",brain[number]), 1, 30)

  #add a new sheet to the excel data frame and add the sensitivity data to this sheet
  addWorksheet(wb, sheetName = paste0(current_name))

  writeData(wb, sheet = paste0(current_name), MR_toCovid_keep, rowNames = TRUE)

  #save the results as a data frame
  Results_MR_toCovid_keep=MR_toCovid_keep # Saves the results in dataframe

  #plot the results
  plot = mr_scatter_plot(Results_MR_toCovid_keep, dataMR_keep)

  #just choose the plot from the list elements
  try({save_plot <- plot[[1]]})

  #save plot
  try({ggsave(filename = paste0(no_dups[number],"_",brain[number]), plot = save_plot, path = paste0(path,"sensitivity/AD_outcome/2SMR/plots/"), width = 6, height = 4, device='tiff', dpi=700)})

}

#save the entire excel workbook with all the sensitivity analyses
saveWorkbook(wb, file = paste0(path,"sensitivity/protein_AD_sensitivity.xlsx"), overwrite = TRUE)

```

# AD -> PROTEIN
# Create a loop for getting all the GSMR data into a Google Sheet
```{r}

# mr_df_original_AD <- AD_exposure_stringent
  # arrange(aesc(qvalue))

mr_df_original_AD <- vroom("/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_exposure_stringent")

# library(vroom)
# library(openxlsx)
# library(cowplot)

mr_df_original_AD$study <- tolower(mr_df_original_AD$study)
mr_df_original_AD$clean_names <-  gsub('\\..*', '', mr_df_original_AD$Outcome)
# mr_df_original_AD$marker_name <- sub('\\_.*', '', mr_df_original_AD$marker_name)
mr_df_original_AD$file_name <- gsub(".gsmr", "", mr_df_original_AD$file_name)

filename <- mr_df_original_AD$file_name
study <- mr_df_original_AD$study
mr_df_original_AD$names <- make.names(mr_df_original_AD$Outcome,unique=T)
names <- mr_df_original_AD$names
marker <- mr_df_original_AD$Outcome
brain <- mr_df_original_AD$Exposure
path <- "/scratch/groups/ukbiobank/usr/alish/AD_MR/"
label <- paste(mr_df_original_AD$clean_names, mr_df_original_AD$study, sep = "_")
no_dups <- make.unique(label, sep = ".")

number <- 1

rm(wb)

wb <- createWorkbook()

for(number in 1:length(filename)){

  current_marker <- filename[number]

  print(filename[number])

  file_path_gsmr <- paste0(path,study[number],"_mr/","/ADexp/output/",current_marker,".eff_plot.gz")

  gsmr_data <- read_gsmr_data(file_path_gsmr)

  gsmr_data$pheno[3] <- label[number]
  gsmr_data$bxy_result[1] <- label[number]
  gsmr_data$bxy_result[4] <- label[number]

  graph <- plot_gsmr_effect(gsmr_data,"AD_Schwartzentruber",label[number], colors()[75])

  ggsave(filename = paste0(label[number]), plot = graph, path = paste0(path,"/sensitivity/AD_exposure/"), width = 6, height = 4, device='tiff', dpi=700)

  snp_data <- gsmr_snp_effect(gsmr_data,"AD_Schwartzentruber",label[number])

  snp_data <- as.data.frame(snp_data)

  addWorksheet(wb, sheetName = paste0(no_dups[number]))

  writeData(wb, sheet = paste0(no_dups[number]), snp_data, rowNames = TRUE)


}

saveWorkbook(wb, file = paste0(path,"sensitivity/AD_protein_gsmr_results.xlsx"), overwrite = TRUE)

```

#TwoSampleMR Sensitivity Analyses
```{r}

mr_df_original_AD <- AD_exposure_stringent
  # arrange(aesc(qvalue))

mr_df_original_AD$file_name <- gsub(".gsmr", "", mr_df_original_AD$file_name)
mr_df_original_AD$clean_names <-  gsub('\\..*', '', mr_df_original_AD$Outcome)
mr_df_original_AD$file_name <- gsub(".txt", "", mr_df_original_AD$file_name)
mr_df_original_AD$Outcome <- sub('\\..*', '', mr_df_original_AD$Outcome)
mr_df_original_AD$name <- paste(mr_df_original_AD$Outcome, mr_df_original_AD$study, sep = "_")
mr_df_original_AD$study <- tolower(mr_df_original_AD$study)

#Read in the SNPs from the excel file
filename <- mr_df_original_AD$file_name
study <- mr_df_original_AD$study
mr_df_original_AD$names <- make.names(mr_df_original_AD$Outcome,unique=T)
names <- mr_df_original_AD$names
marker <- mr_df_original_AD$Outcome
brain <- mr_df_original_AD$Exposure
path <- "/scratch/groups/ukbiobank/usr/alish/AD_MR/"
all_protein <- list.files("/scratch/groups/ukbiobank/usr/alish/AD_MR/sensitivity/AD_exposure/", include.dirs = F)
all_protein <- all_protein[-1]
label <- paste(mr_df_original_AD$clean_names, mr_df_original_AD$study, sep = "_")
filename <- toupper(filename)
no_dups <- make.unique(label, sep = ".")


#this is only done once to get the smaller AD GWAS
# AD_gwas_sensitivity <- vroom("/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_Schwartzentruber.txt")
#
# AD_gwas_sensitivity <- AD_gwas_sensitivity %>%
#   subset(p_value<5*10^-8)
# write.table(AD_gwas_sensitivity, file = paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR/sensitivity/AD_gwas_sensitivity.txt"), col.names=T, row.names=F, quote=F,sep = "\t")


# Make the columns as follows:
# SNP                 
# beta                
# SE                 
# effect_allele      
# non-effective allele
# p-value            
# effect_allele freq

number <- 1

# library(TwoSampleMR)

rm(wb)

wb <- createWorkbook()

for(number in 1:length(filename)){

  #using TwoSampleMR, read in the outcome of interest
  exposure_dat <- read_exposure_data(
  filename = paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR/sensitivity/AD_gwas_sensitivity.txt"),
  sep = "\t",                
  snp_col = "variant_id",          
  beta_col = "beta",         
  se_col = "standard_error",        
  effect_allele_col = "effect_allele",  
  other_allele_col = "other_allele",
  eaf = "effect_allele_frequency",
  samplesize_col = "472868",
  pval_col = "p_value")

  exposure_dat$exposure=paste0("AD")

  #read in the workbook with all our significant proteins
  current_protein <- readWorkbook(xlsxFile = paste0(path,"sensitivity/protein_AD_sensitivity.xlsx"), sheet = paste0(marker[number]), rowNames = TRUE)

  #get the whole GWAS from the same protein
  original_protein <- vroom(paste0("/scratch/groups/gwas_sumstats/cleaned/blood_biomarkers/",filename[number],".gz"))

  #get all the columns that we need
  full_df <- original_protein %>%
  select(SNP,
         beta = BETA,
         se = SE,
         effect_allele = A1,
         other_allele = A2,
         eaf = MAF
         )

  #format
  outcome_dat <- format_data(full_df, type = "outcome")

  outcome_dat$outcome=paste0(marker[number])

  exposure_dat <- clump_data(exposure_dat, clump_r2 = 0.05)

  #Harmonisation of SNP instruments between exposures and outcomes
  harmonized <- harmonise_data(exposure_dat = exposure_dat, outcome_dat = outcome_dat, action=2)

  # get the data ready
  # all exposures -> Covid
  dataMR_keep=subset(harmonized, mr_keep==TRUE)

  # perform TwoSampleMR for all pairs
  MR_toCovid_keep<- mr(dataMR_keep)

  #get the name of the current marker and brain volume
  current_name <- substring(paste0(brain[number],"_",label[number]), 1, 30)

  #add a new sheet to the excel data frame and add the sensitivity data to this sheet
  addWorksheet(wb, sheetName = paste0(current_name))

  writeData(wb, sheet = paste0(current_name), MR_toCovid_keep, rowNames = TRUE)

  #save the results as a data frame
  Results_MR_toCovid_keep=MR_toCovid_keep # Saves the results in dataframe

  #plot the results
  plot = mr_scatter_plot(Results_MR_toCovid_keep, dataMR_keep)

  #just choose the plot from the list elements
  try({save_plot <- plot[[1]]})

  #save plot
  try({ggsave(filename = paste0(brain[number],"_",label[number]), plot = save_plot, path = paste0(path,"sensitivity/AD_exposure/2SMR/plots/"), width = 6, height = 4, device='tiff', dpi=700)})

}

#save the entire excel workbook with all the sensitivity analyses
saveWorkbook(wb, file = paste0(path,"sensitivity/AD_protein_brain_sensitivity.xlsx"), overwrite = TRUE)

```


#MVMR
#Set-up
```{r echo=FALSE}
rm(list=ls())
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

setwd("/scratch/groups/ukbiobank/usr/alish/AD_MR/")
```

```{r include=FALSE}
library(data.table)
library(jtools)
library(knitr)
library(broom)
library(sandwich)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(sgof)
library(TwoSampleMR)
library(qvalue)
library(kableExtra)
library(vroom)

```

```{r}

source("/scratch/users/k1463257/packages/demo_AMD/summary_mvMR_SSS.R")
source("/scratch/users/k1463257/packages/demo_AMD/summary_mvMR_BF.R")

```

#PROTEIN -> AD MVMR
#Create matrix to be used in method
```{r}

AD_outcome_stringent <- vroom(file = "/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_outcome_stringent")

head(AD_outcome_stringent)

# library(vroom)
# library(openxlsx)
# library(cowplot)
# library(vroom)

AD_outcome_stringent$study <- tolower(AD_outcome_stringent$study)
AD_outcome_stringent$clean_names <-  gsub('\\..*', '', AD_outcome_stringent$Exposure)
AD_outcome_stringent$file_name <- gsub(".gsmr", "", AD_outcome_stringent$file_name)

filename <- AD_outcome_stringent$file_name
study <- AD_outcome_stringent$study
AD_outcome_stringent$names <- make.names(AD_outcome_stringent$Exposure,unique=T)
names <- AD_outcome_stringent$names
marker <- AD_outcome_stringent$Exposure
brain <- AD_outcome_stringent$Outcome
path <- "/scratch/groups/ukbiobank/usr/alish/AD_MR/"
label <- paste(AD_outcome_stringent$clean_names, AD_outcome_stringent$study, sep = "_")
no_dups <- make.unique(label, sep = ".")

number <- 1

# first we need to get a list of all the SNPs from our markers
for(number in 1:length(filename)){

  current_marker <- filename[number]

  file_path_gsmr <- paste0(path,study[number],"_","mr/output/",current_marker,".eff_plot.gz")

  gsmr_data <- read_gsmr_data(file_path_gsmr)

  # graph <- plot_gsmr_effect(gsmr_data,marker[number],"AD_Schwartzentruber", colors()[75])

  # ggsave(filename = paste0(marker[number],"_",brain[number]), plot = graph, path = paste0(path,"plots/"), width = 6, height = 4, device='tiff', dpi=700)

  snp_data <- gsmr_snp_effect(gsmr_data,marker[number],"AD_Schwartzentruber")

  snp_data <- as.data.frame(snp_data)

  write.table(snp_data, file = paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR//sensitivity/MVMR/",no_dups[number]), col.names=T, row.names=F, quote=F,sep = "\t")

}

```

#POSITIVE
```{r}
#POSITIVE

AD_outcome_mvmr <- vroom(file = "/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_outcome_stringent")

AD_outcome_mvmr <- AD_outcome_mvmr %>%
  filter(Beta > 0)

AD_outcome_mvmr$study <- tolower(AD_outcome_mvmr$study)
AD_outcome_mvmr$clean_names <-  gsub('\\..*', '', AD_outcome_mvmr$Exposure)
AD_outcome_mvmr$file_name <- gsub(".gsmr", "", AD_outcome_mvmr$file_name)

study <- AD_outcome_mvmr$study
AD_outcome_mvmr$names <- make.names(AD_outcome_mvmr$Exposure,unique=T)
names <- AD_outcome_mvmr$names
marker <- AD_outcome_mvmr$Exposure
brain <- AD_outcome_mvmr$Outcome
path <- "/scratch/groups/ukbiobank/usr/alish/AD_MR/"
label <- paste(AD_outcome_mvmr$clean_names, AD_outcome_mvmr$study, sep = "_")
no_dups <- make.unique(label, sep = ".")
filename <- gsub(".txt", "", AD_outcome_mvmr$file_name)


number <- 1
zones = list()

ad <- vroom(paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_Schwartzentruber.txt"))

#next we need to read the SNPs into a single data frame
for(number in 1:length(filename)){ #change to for(number in 1:length(filename)){

  ename <- paste0(label[number])
  ename
  zones[[ename]] <- vroom(paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR/sensitivity/MVMR/",label[number]))

  matrix <- list()

  snps <- lapply(zones, `[`, 1)

  just_snps <- as.data.frame(do.call(rbind, snps))       # Convert list to data frame columns
  rownames(just_snps)<- c()

}  

merged <- merge(just_snps, ad, by = 1)
merged <- merged %>%
  rename(SNP = snp)

joined_data <- merged
filename <- toupper(filename)

# finally we need to match all the variants from all the markers into a single data frame. This kept crashing, which is why it has been split so many times
for(number in 1:length(filename)){ #change to for(number in 1:length(filename)){

  original_protein <- vroom(paste0("/scratch/groups/gwas_sumstats/cleaned/blood_biomarkers/",filename[number],".gz"),)

  original_protein = original_protein[!duplicated(original_protein$SNP),]

  original_protein <- original_protein %>%
   select(SNP, BETA)

  joined_data = merge(joined_data, original_protein, by = 'SNP', all.x = TRUE)

  names(joined_data)[names(joined_data) == "BETA"] <- paste0(no_dups[number],"_beta")

}

# save the data frame half way as this keep crashing
#export the final data frame as it takes such a long time to make
write.table(joined_data, file = paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR//sensitivity/MVMR/joined_data_positive"), col.names=T, row.names=F, quote=F,sep = "\t")

```

```{r}

#import the data frame and make a labelled list
joined_data <- fread(paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR//sensitivity/MVMR/joined_data_positive"), verbose = T, data.table = F, fill=TRUE)

# joined_data <- joined_data[ , apply(joined_data, 2, function(x) !any(is.na(x)))]

joined_data <-  joined_data[complete.cases(joined_data), ]


ad_beta <- joined_data$beta
ad_se <- joined_data$standard_error
all_beta <- joined_data[9:ncol(joined_data)]
annotate <- joined_data %>%
  select(SNP,
        effect_allele,
        other_allele,
        effect_allele_frequency)


my_list <- list()                           # Create empty list
my_list <- list(ad_beta, ad_se, all_beta, annotate)

names(my_list)[1] <- "ad_beta"
names(my_list)[2] <- "ad_se"
names(my_list)[3] <- "betaX"
names(my_list)[4] <- "annotate"

```

## 1. Loading the data and removing missing values and outliers and influential points and outliers from the first iteration
All relevant input data is provided in the Rdata "amd_example".
```{r message=FALSE, warning=FALSE}
# load("/scratch/users/k1463257/packages/demo_AMD/amd_example")
# betaX = amd_example$betaX
# amd_beta = amd_example$amd_beta
# amd_se = amd_example$amd_se
# rs = amd_example$annotate[,1]
# genes = amd_example$annotate[,7]
# dim(betaX)
# colnames(betaX)
# rf = colnames(betaX)

betaX = my_list$betaX
amd_beta = my_list$ad_beta
amd_se = my_list$ad_se
rs = my_list$annotate[,1]
dim(betaX)
colnames(betaX)
rf = colnames(betaX)
```

There was one influential variant in the LIPC gene region and two outliers in the APOE and FUT2 gene region. We are removing these 3 data points for the following analysis.
```{r message=FALSE, warning=FALSE}
# LIPC = which(genes == "LIPC")
# FUT2 = which(genes == "FUT2")
# APOE = which(genes == "APOE")
# exclude_vec = c(LIPC,FUT2,APOE)
# betaX=betaX[-exclude_vec,]
# amd_beta = amd_beta[-exclude_vec]
# amd_se = amd_se[-exclude_vec]
# rs = rs[-exclude_vec]
# genes = genes[-exclude_vec]
```

Next, we perform an inverse variance weighting (IVW) based on the standard error of the amd beta effect estimates prior to subsequent analysis.
```{r message=FALSE, warning=FALSE}
betaX_ivw = betaX / amd_se
amd_beta_ivw = amd_beta / amd_se
dim(betaX_ivw)
length(amd_beta_ivw)
```

## 2. Analysis: Univariable MR
Univariate MR for each metabolite, ranked by minimum p-value.
```{r message=FALSE, warning=FALSE}
beta_coeff = rep(0, ncol(betaX_ivw))
p_val = rep(0, ncol(betaX_ivw))
for(i in 1:ncol(betaX_ivw)){
	lm_out = lm(amd_beta_ivw ~ betaX_ivw[,i]-1)
	beta_coeff[i] =summary(lm_out)$coeff[1]
	p_adjust =summary(lm_out)$coeff[4]*49
	if(p_adjust>1){p_val[i] = 1}
	else{p_val[i] = p_adjust}
}
mat_out = cbind(colnames(betaX_ivw),beta_coeff, p_val)
sort_p=sort(p_val, index.return=TRUE, decreasing = FALSE)
colnames(mat_out) = c("rf","beta with AMD","p")
mat_out[sort_p$ix,]
```


## 3. Analysis: Bayesian model selection with stochastic search
We create an object of class mvMRInput and we run MR-BMA allowing for models with up to 12 risk factors and a prior probability of 0.1 reflecting an a priori model size of three risk factors. Please note for runtime reasons max_iter is set to 100, please increase to 100k for stable results.
```{r message=FALSE, warning=FALSE}
set.seed(12345)
amd_nmr_input=new("mvMRInput", betaX = as.matrix(betaX_ivw), betaY = as.matrix(amd_beta_ivw), snps=rs, exposure=rf, outcome = "amd")
BMA_output=summarymvMR_SSS(amd_nmr_input,kmin=1,kmax=12, prior_prob=0.1, max_iter=1000)
```

The best model with the highest posterior evidence:
```{r message=FALSE, warning=FALSE}
best_model_ind=as.numeric(unlist(strsplit(BMA_output@BestModel, ",")))
rf[best_model_ind]
BMA_output@BestModel_Estimate
```
What are the next best individual models?
```{r message=FALSE, warning=FALSE}
best.model.out = sss.report.best.model(BMA_output, prior_sigma=0.5, top = 10, write.out = TRUE, csv.file.name="amd_best_10models_n145")
best.model.out
```

MR-BMA output: Marginal inclusion probabilities and model-averaged effect (MACE) for each risk factor (top 10)
```{r message=FALSE, warning=FALSE}
mr.bma.out = sss.report.mr.bma(BMA_output, top = 10, write.out = TRUE, csv.file.name="amd_mr_bma_n145")
mr.bma.out
```

MR-BMA permutation: Compute empirical p-values based on permutations. For illustration reasons we only perform 100 permutations here. Ideally, the permutation should be repeated 100k times, Please note this may require a long runtime.
```{r message=FALSE, warning=FALSE}
permute_bma = create.permutations(BMA_output, nrepeat = 1000, save.matrix=TRUE, file.name = "permutation_mrBMA.csv")
empirical.p = calculate.p(BMA_output, permute_bma)
empirical.p
```


## 4. Model diagnostics for outliers (Cook's D) and influential points (Q) for all models with pp>0.02
For model diagnostics we consider all individual models that had a posterior probability larger than 0.02. Modify this value (diag_ppthresh) accordingly for your study.
```{r message=FALSE, warning=FALSE}
diag_ppthresh = 0.02
nr_diag = length(which(best.model.out[,2] >= diag_ppthresh))
nr_diag
model_index = names(which(best.model.out[,2] >= diag_ppthresh))
model_index
```

The following loop computes
- the predicted genetic association (hat(beta_Y)) based on the model
- Cook's distance and its threshold for each genetic variant given the model
- the heterogeneity statistic q for each genetic variant given the model

```{r message=FALSE, warning=FALSE}
#initialise
title = rep("1", nr_diag)
predicted_amd = matrix(ncol=nr_diag, nrow=length(amd_beta_ivw))
cD = matrix(ncol=nr_diag, nrow=length(amd_beta_ivw))
cD_thresh = vector(length=nr_diag)
Q = matrix(ncol=nr_diag, nrow=length(amd_beta_ivw))

# fill with loop
for(i in 1:nr_diag){
	print(as.numeric(unlist(strsplit(model_index[i], ","))))
	if(length(as.numeric(unlist(strsplit(model_index[i], ","))))>1){
		betaX_model = do.call(cbind, betaX_ivw[,as.numeric(unlist(strsplit(model_index[i], ",")))])
	}
	else{
		betaX_model = as.matrix(betaX_ivw[,as.numeric(unlist(strsplit(model_index[i], ",")))])
	}
	title[i] = paste(rf[as.numeric(unlist(strsplit(model_index[i], ",")))],collapse=' + ')
	sigma_vec = rep(0.5, ncol(betaX_model))
	cD[,i] = cooksD(amd_beta_ivw,betaX_model,sigma_vec)$cooksD
	cD_thresh[i] = cooksD(amd_beta_ivw,betaX_model,sigma_vec)$cooksD_thresh
	H_fm = betaX_model %*% solve(t(betaX_model) %*% betaX_model + sigma_vec^{-2} ) %*% t(betaX_model)
	predicted_amd[,i] = H_fm %*% amd_beta_ivw
	Q[,i] = (amd_beta_ivw-predicted_amd[,i])^2

}
```



## Influential points via Cook's D
In multivariable MR diagnostics we look at scatterplots the predicted genetic association (hat(beta_Y)) based on the model including possibly more than one risk factor (note that hat(beta_Y) = theta betaX is a linear combination of the risk factors in the model) against the actually observed genetic associations with the outcome. Influential points (computed by Cooks distance (cD)) are marked by the regions the SNPs fall in where we use the median of a F distribution as threshold (saved in cD_thresh).
```{r, echo=FALSE, include = TRUE, fig.height = 10, fig.width = 11}
for(i in 1:nr_diag){

	df = data.frame(x=predicted_amd[,i], y =amd_beta_ivw, cD = cD[,i], genes = genes)
	print(ggplot(df, aes(x, y)) +  geom_point(aes(colour = cD), size =4) + scale_colour_gradientn(colours = c("white", "orange", "red", "darkred"), values=c(0,0.027,0.1,0.5,1))  + labs(x = "predicted beta amd", y="observed beta amd", colour="Cooks D") + geom_hline(yintercept = 0, linetype="dotted") + geom_vline(xintercept = 0, linetype="dotted") +  geom_text(aes(label=ifelse(cD>cD_thresh[i],as.character(genes),'')),hjust=0.5, vjust=-1, size=5) + theme(axis.text.x = element_text(size = 13), axis.text.y = element_text(size = 13), axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18), legend.text=element_text(size=16),legend.title=element_text(size=18)) + ggtitle(title[i]))

}
```


In numbers, here is a table of Cook's distance of the top models, sorted by maximum Cooks Distance in any of the models considered.
```{r message=FALSE, warning=FALSE}
maxCD=apply(cD, MARGIN=1, FUN=max)
sort.ix = sort.int(maxCD, decreasing=TRUE, index.return=TRUE)
cooksD_tab=cbind(rs,genes,round(cD,digits=3), round(maxCD,digits=3))
#colnames(cooksD_tab)=c("rs","region","cooksD1","cooksD2","cooksD3","cooksD4","max cooksD")
cooksD_tab[sort.ix$ix,][1:30,]
```


Threshold of Cook's distance  according to F-statistic with d and n-d degrees of freedom.
```{r message=FALSE, warning=FALSE}
cD_thresh
for(i in 1:nr_diag){
	print(genes[which(cD[,i] > cD_thresh[i])])
}
```



## Outliers with Q

The same diagnostic plots as above, but here the color code shows the q-statistic for each genetic variant used as instrumental variable. Outliers (computed by q>10) are marked by the regions the SNPs fall in.
```{r, echo=FALSE, include = TRUE, fig.height = 10, fig.width = 11}
for(i in 1:nr_diag){

	df = data.frame(x=predicted_amd[,i], y =amd_beta_ivw, Q = Q[,i], genes = genes)
	print(ggplot(df, aes(x, y)) +  geom_point(aes(colour = Q), size =4) + scale_colour_gradientn(colours = c("white", "yellow", "green", "darkgreen"), values=c(0,0.027,0.1,0.5,1))  + labs(x = "predicted beta amd", y="observed beta amd", colour="Q") + geom_hline(yintercept = 0, linetype="dotted") + geom_vline(xintercept = 0, linetype="dotted") +  geom_text(aes(label=ifelse(Q>10,as.character(genes),'')),hjust=0.5, vjust=-1, size=5) + theme(axis.text.x = element_text(size = 13), axis.text.y = element_text(size = 13), axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18), legend.text=element_text(size=16),legend.title=element_text(size=18)) + ggtitle(title[i]))

}
```

In numbers, here is a table of the q-statistic of the top models, sorted by the maximum in any of the models considered.
```{r message=FALSE, warning=FALSE}
maxQ=apply(Q, MARGIN=1, FUN=max)
sort.ix = sort.int(maxQ, decreasing=TRUE, index.return=TRUE)
Q_tab=cbind(rs,genes,round(Q,digits=3), round(maxQ,digits=3))
Q_tab[sort.ix$ix,][1:30,]

```


#NEGATIVE
```{r}
#POSITIVE

AD_outcome_mvmr <- vroom(file = "/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_outcome_stringent")

AD_outcome_mvmr <- AD_outcome_mvmr %>%
  filter(Beta < 0)

AD_outcome_mvmr$study <- tolower(AD_outcome_mvmr$study)
AD_outcome_mvmr$clean_names <-  gsub('\\..*', '', AD_outcome_mvmr$Exposure)
AD_outcome_mvmr$file_name <- gsub(".gsmr", "", AD_outcome_mvmr$file_name)

study <- AD_outcome_mvmr$study
AD_outcome_mvmr$names <- make.names(AD_outcome_mvmr$Exposure,unique=T)
names <- AD_outcome_mvmr$names
marker <- AD_outcome_mvmr$Exposure
brain <- AD_outcome_mvmr$Outcome
path <- "/scratch/groups/ukbiobank/usr/alish/AD_MR/"
label <- paste(AD_outcome_mvmr$clean_names, AD_outcome_mvmr$study, sep = "_")
no_dups <- make.unique(label, sep = ".")
filename <- gsub(".txt", "", AD_outcome_mvmr$file_name)


number <- 1
zones = list()

ad <- vroom(paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR/AD_Schwartzentruber.txt"))

#next we need to read the SNPs into a single data frame
for(number in 1:length(filename)){ #change to for(number in 1:length(filename)){

  ename <- paste0(label[number])
  ename
  zones[[ename]] <- vroom(paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR/sensitivity/MVMR/",label[number]))

  matrix <- list()

  snps <- lapply(zones, `[`, 1)

  just_snps <- as.data.frame(do.call(rbind, snps))       # Convert list to data frame columns
  rownames(just_snps)<- c()

}  

merged <- merge(just_snps, ad, by = 1)
merged <- merged %>%
  rename(SNP = snp)

joined_data <- merged
filename <- toupper(filename)

# finally we need to match all the variants from all the markers into a single data frame. This kept crashing, which is why it has been split so many times
for(number in 1:length(filename)){ #change to for(number in 1:length(filename)){

  original_protein <- vroom(paste0("/scratch/groups/gwas_sumstats/cleaned/blood_biomarkers/",filename[number],".gz"),)

  original_protein = original_protein[!duplicated(original_protein$SNP),]

  original_protein <- original_protein %>%
   select(SNP, BETA)

  joined_data = merge(joined_data, original_protein, by = 'SNP', all.x = TRUE)

  names(joined_data)[names(joined_data) == "BETA"] <- paste0(no_dups[number],"_beta")

}

# save the data frame half way as this keep crashing
#export the final data frame as it takes such a long time to make
write.table(joined_data, file = paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR//sensitivity/MVMR/joined_data_negative"), col.names=T, row.names=F, quote=F,sep = "\t")

```

```{r}

#import the data frame and make a labelled list
joined_data <- fread(paste0("/scratch/groups/ukbiobank/usr/alish/AD_MR//sensitivity/MVMR/joined_data_negative"), verbose = T, data.table = F, fill=TRUE)

# joined_data <- joined_data[ , apply(joined_data, 2, function(x) !any(is.na(x)))]

joined_data <-  joined_data[complete.cases(joined_data), ]


ad_beta <- joined_data$beta
ad_se <- joined_data$standard_error
all_beta <- joined_data[9:ncol(joined_data)]
annotate <- joined_data %>%
  select(SNP,
        effect_allele,
        other_allele,
        effect_allele_frequency)


my_list <- list()                           # Create empty list
my_list <- list(ad_beta, ad_se, all_beta, annotate)

names(my_list)[1] <- "ad_beta"
names(my_list)[2] <- "ad_se"
names(my_list)[3] <- "betaX"
names(my_list)[4] <- "annotate"

```

## 1. Loading the data and removing missing values and outliers and influential points and outliers from the first iteration
All relevant input data is provided in the Rdata "amd_example".
```{r message=FALSE, warning=FALSE}
# load("/scratch/users/k1463257/packages/demo_AMD/amd_example")
# betaX = amd_example$betaX
# amd_beta = amd_example$amd_beta
# amd_se = amd_example$amd_se
# rs = amd_example$annotate[,1]
# genes = amd_example$annotate[,7]
# dim(betaX)
# colnames(betaX)
# rf = colnames(betaX)

betaX = my_list$betaX
amd_beta = my_list$ad_beta
amd_se = my_list$ad_se
rs = my_list$annotate[,1]
dim(betaX)
colnames(betaX)
rf = colnames(betaX)
```

There was one influential variant in the LIPC gene region and two outliers in the APOE and FUT2 gene region. We are removing these 3 data points for the following analysis.
```{r message=FALSE, warning=FALSE}
# LIPC = which(genes == "LIPC")
# FUT2 = which(genes == "FUT2")
# APOE = which(genes == "APOE")
# exclude_vec = c(LIPC,FUT2,APOE)
# betaX=betaX[-exclude_vec,]
# amd_beta = amd_beta[-exclude_vec]
# amd_se = amd_se[-exclude_vec]
# rs = rs[-exclude_vec]
# genes = genes[-exclude_vec]
```

Next, we perform an inverse variance weighting (IVW) based on the standard error of the amd beta effect estimates prior to subsequent analysis.
```{r message=FALSE, warning=FALSE}
betaX_ivw = betaX / amd_se
amd_beta_ivw = amd_beta / amd_se
dim(betaX_ivw)
length(amd_beta_ivw)
```

## 2. Analysis: Univariable MR
Univariate MR for each metabolite, ranked by minimum p-value.
```{r message=FALSE, warning=FALSE}
beta_coeff = rep(0, ncol(betaX_ivw))
p_val = rep(0, ncol(betaX_ivw))
for(i in 1:ncol(betaX_ivw)){
	lm_out = lm(amd_beta_ivw ~ betaX_ivw[,i]-1)
	beta_coeff[i] =summary(lm_out)$coeff[1]
	p_adjust =summary(lm_out)$coeff[4]*49
	if(p_adjust>1){p_val[i] = 1}
	else{p_val[i] = p_adjust}
}
mat_out = cbind(colnames(betaX_ivw),beta_coeff, p_val)
sort_p=sort(p_val, index.return=TRUE, decreasing = FALSE)
colnames(mat_out) = c("rf","beta with AMD","p")
mat_out[sort_p$ix,]
```


## 3. Analysis: Bayesian model selection with stochastic search
We create an object of class mvMRInput and we run MR-BMA allowing for models with up to 12 risk factors and a prior probability of 0.1 reflecting an a priori model size of three risk factors. Please note for runtime reasons max_iter is set to 100, please increase to 100k for stable results.
```{r message=FALSE, warning=FALSE}
set.seed(12345)
amd_nmr_input=new("mvMRInput", betaX = as.matrix(betaX_ivw), betaY = as.matrix(amd_beta_ivw), snps=rs, exposure=rf, outcome = "amd")
BMA_output=summarymvMR_SSS(amd_nmr_input,kmin=1,kmax=12, prior_prob=0.1, max_iter=100)
```

The best model with the highest posterior evidence:
```{r message=FALSE, warning=FALSE}
best_model_ind=as.numeric(unlist(strsplit(BMA_output@BestModel, ",")))
rf[best_model_ind]
BMA_output@BestModel_Estimate
```
What are the next best individual models?
```{r message=FALSE, warning=FALSE}
best.model.out = sss.report.best.model(BMA_output, prior_sigma=0.5, top = 10, write.out = TRUE, csv.file.name="amd_best_10models_n145")
best.model.out
```

MR-BMA output: Marginal inclusion probabilities and model-averaged effect (MACE) for each risk factor (top 10)
```{r message=FALSE, warning=FALSE}
mr.bma.out = sss.report.mr.bma(BMA_output, top = 10, write.out = TRUE, csv.file.name="amd_mr_bma_n145")
mr.bma.out
```

MR-BMA permutation: Compute empirical p-values based on permutations. For illustration reasons we only perform 100 permutations here. Ideally, the permutation should be repeated 100k times, Please note this may require a long runtime.
```{r message=FALSE, warning=FALSE}
permute_bma = create.permutations(BMA_output, nrepeat = 100, save.matrix=TRUE, file.name = "permutation_mrBMA.csv")
empirical.p = calculate.p(BMA_output, permute_bma)
empirical.p
```


## 4. Model diagnostics for outliers (Cook's D) and influential points (Q) for all models with pp>0.02
For model diagnostics we consider all individual models that had a posterior probability larger than 0.02. Modify this value (diag_ppthresh) accordingly for your study.
```{r message=FALSE, warning=FALSE}
diag_ppthresh = 0.02
nr_diag = length(which(best.model.out[,2] >= diag_ppthresh))
nr_diag
model_index = names(which(best.model.out[,2] >= diag_ppthresh))
model_index
```

The following loop computes
- the predicted genetic association (hat(beta_Y)) based on the model
- Cook's distance and its threshold for each genetic variant given the model
- the heterogeneity statistic q for each genetic variant given the model

```{r message=FALSE, warning=FALSE}
#initialise
title = rep("1", nr_diag)
predicted_amd = matrix(ncol=nr_diag, nrow=length(amd_beta_ivw))
cD = matrix(ncol=nr_diag, nrow=length(amd_beta_ivw))
cD_thresh = vector(length=nr_diag)
Q = matrix(ncol=nr_diag, nrow=length(amd_beta_ivw))

# fill with loop
for(i in 1:nr_diag){
	print(as.numeric(unlist(strsplit(model_index[i], ","))))
	if(length(as.numeric(unlist(strsplit(model_index[i], ","))))>1){
		betaX_model = do.call(cbind, betaX_ivw[,as.numeric(unlist(strsplit(model_index[i], ",")))])
	}
	else{
		betaX_model = as.matrix(betaX_ivw[,as.numeric(unlist(strsplit(model_index[i], ",")))])
	}
	title[i] = paste(rf[as.numeric(unlist(strsplit(model_index[i], ",")))],collapse=' + ')
	sigma_vec = rep(0.5, ncol(betaX_model))
	cD[,i] = cooksD(amd_beta_ivw,betaX_model,sigma_vec)$cooksD
	cD_thresh[i] = cooksD(amd_beta_ivw,betaX_model,sigma_vec)$cooksD_thresh
	H_fm = betaX_model %*% solve(t(betaX_model) %*% betaX_model + sigma_vec^{-2} ) %*% t(betaX_model)
	predicted_amd[,i] = H_fm %*% amd_beta_ivw
	Q[,i] = (amd_beta_ivw-predicted_amd[,i])^2

}
```



## Influential points via Cook's D
In multivariable MR diagnostics we look at scatterplots the predicted genetic association (hat(beta_Y)) based on the model including possibly more than one risk factor (note that hat(beta_Y) = theta betaX is a linear combination of the risk factors in the model) against the actually observed genetic associations with the outcome. Influential points (computed by Cooks distance (cD)) are marked by the regions the SNPs fall in where we use the median of a F distribution as threshold (saved in cD_thresh).
```{r, echo=FALSE, include = TRUE, fig.height = 10, fig.width = 11}
for(i in 1:nr_diag){

	df = data.frame(x=predicted_amd[,i], y =amd_beta_ivw, cD = cD[,i], genes = genes)
	print(ggplot(df, aes(x, y)) +  geom_point(aes(colour = cD), size =4) + scale_colour_gradientn(colours = c("white", "orange", "red", "darkred"), values=c(0,0.027,0.1,0.5,1))  + labs(x = "predicted beta amd", y="observed beta amd", colour="Cooks D") + geom_hline(yintercept = 0, linetype="dotted") + geom_vline(xintercept = 0, linetype="dotted") +  geom_text(aes(label=ifelse(cD>cD_thresh[i],as.character(genes),'')),hjust=0.5, vjust=-1, size=5) + theme(axis.text.x = element_text(size = 13), axis.text.y = element_text(size = 13), axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18), legend.text=element_text(size=16),legend.title=element_text(size=18)) + ggtitle(title[i]))

}
```


In numbers, here is a table of Cook's distance of the top models, sorted by maximum Cooks Distance in any of the models considered.
```{r message=FALSE, warning=FALSE}
maxCD=apply(cD, MARGIN=1, FUN=max)
sort.ix = sort.int(maxCD, decreasing=TRUE, index.return=TRUE)
cooksD_tab=cbind(rs,genes,round(cD,digits=3), round(maxCD,digits=3))
#colnames(cooksD_tab)=c("rs","region","cooksD1","cooksD2","cooksD3","cooksD4","max cooksD")
cooksD_tab[sort.ix$ix,][1:30,]
```


Threshold of Cook's distance  according to F-statistic with d and n-d degrees of freedom.
```{r message=FALSE, warning=FALSE}
cD_thresh
for(i in 1:nr_diag){
	print(genes[which(cD[,i] > cD_thresh[i])])
}
```



## Outliers with Q

The same diagnostic plots as above, but here the color code shows the q-statistic for each genetic variant used as instrumental variable. Outliers (computed by q>10) are marked by the regions the SNPs fall in.
```{r, echo=FALSE, include = TRUE, fig.height = 10, fig.width = 11}
for(i in 1:nr_diag){

	df = data.frame(x=predicted_amd[,i], y =amd_beta_ivw, Q = Q[,i], genes = genes)
	print(ggplot(df, aes(x, y)) +  geom_point(aes(colour = Q), size =4) + scale_colour_gradientn(colours = c("white", "yellow", "green", "darkgreen"), values=c(0,0.027,0.1,0.5,1))  + labs(x = "predicted beta amd", y="observed beta amd", colour="Q") + geom_hline(yintercept = 0, linetype="dotted") + geom_vline(xintercept = 0, linetype="dotted") +  geom_text(aes(label=ifelse(Q>10,as.character(genes),'')),hjust=0.5, vjust=-1, size=5) + theme(axis.text.x = element_text(size = 13), axis.text.y = element_text(size = 13), axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18), legend.text=element_text(size=16),legend.title=element_text(size=18)) + ggtitle(title[i]))

}
```

In numbers, here is a table of the q-statistic of the top models, sorted by the maximum in any of the models considered.
```{r message=FALSE, warning=FALSE}
maxQ=apply(Q, MARGIN=1, FUN=max)
sort.ix = sort.int(maxQ, decreasing=TRUE, index.return=TRUE)
Q_tab=cbind(rs,genes,round(Q,digits=3), round(maxQ,digits=3))
Q_tab[sort.ix$ix,][1:30,]

```
